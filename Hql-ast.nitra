using Nitra;
using Nitra.Declarations;
using System;

namespace Hql
{
  ast Start
  {
    Query : Query;
  }

  ast Query
  {
     SelectStm : SelectStm;
	 Union     : string;
	 UnionAll  : string;
  }

  ast SelectStm
  {
     FromClause : FromClause?;
	 SelectClause : SelectClause;
	 WhereClause : WhereClause?;
	 GroupClause : GroupClause?;
	 OrderClause : OrderClause?;
  }  

  ast OrderClause
  {
     OrderFields : OrderField;
  }

  abstract ast OrderFieldExpression : OrderField
  {
    Expression : Expression;
  }

  abstract ast OrderField
  {
    | OrderAsc : OrderFieldExpression
    | OrderDesc : OrderFieldExpression
  }

  ast GroupClause
  {
     Expressions : Expression*;
	 HavingClause : HavingClause?;
  }

  ast HavingClause
  {
    LogicalExpression : LogicalExpression;
  }

  ast WhereClause
  {
     LogicalExpression : LogicalExpression;
  }

  ast SelectClause
  {
     Distinct : bool;
	 Columns : Column*;
  }

  abstract ast Column
  {
    | AllTabAllFields
	| OneTabAllFields { TableName : QualifiedIdentifier; }
	| ColumnExpressionWithAlias { Expression : Expression; Alias : string; }
  }

  ast FromClause
  {
    TableSources : TableSource*;
  }

  ast TableSource
  {
    TableSourceItem : TableSourceItem; 
	JoinParts       : JoinPart*;
  }

  abstract ast JoinPart
  {
    | Join { JoinType : JoinType; RightTable : TableSource; Expression : LogicalExpression; }
	| Link { TableNameFull : TableNameFull; }
  }

  ast JoinType
  {
     Type : JoinTypes;
  }

  abstract ast JoinTypes
  {
    | Inner
	| Left
	| Right
	| Full
  }

  abstract ast TableSourceItem
  {
     | SubQuery            { Query : Query; Alias : Alias; } 
	 | TableSourceNameFull { TableNameFull : TableNameFull; }
  }

  ast TableNameFull
  {
     TableName : QualifiedIdentifier; 
	 Alias     : string;
  }

  ast Alias
  {
     Name : string;
  }

  ast QualifiedIdentifier
  {
     QualifiedIdentifierParts : QualifiedIdentifierPartPair*;
  }

  ast QualifiedIdentifierPartPair
  {
     QualifiedIdentifierPart : QualifiedIdentifierPart;
	 Delimiter               : Delimiter;
  }

  ast QualifiedIdentifierPart
  {
     Reference : string;
  }

  abstract ast Delimiter
  {
    |FullJoinDelimiter
	|RightJoinDelimiter
	|LeftJoinDelimiter
	|DefaultJoinDelimiter
  }

  abstract ast MyValues
  {
    | QueryExpression    { Query : Query;}
	| BracketsExpression { ExpressionList : Expression*;}
  }

  abstract ast LogicalUnary : LogicalExpression
  {
      Expr1 : LogicalExpression;
  }

  abstract ast ExpLogicalUnary : LogicalExpression
  {
      Expr1 : Expression;
  }

  abstract ast LogicalBinary : LogicalExpression
  {
      Expr1 : LogicalExpression;
	  Expr2 : LogicalExpression;
  }

  abstract ast ExpLogicalBinary : LogicalExpression
  {
      Expr1 : Expression;
	  Expr2 : Expression;
  }

  abstract ast LogicalIn : LogicalExpression
  {
      Expr1  : Expression;
	  Values : MyValues;
  }

  abstract ast LogicalExists : LogicalExpression
  {
     Expr1 : Expression;
	 Query : Query;
  }

  abstract ast LogicalExpression
  {
    | ValueIsNotNull : ExpLogicalUnary
	| ValueIsNull    : ExpLogicalUnary
	| Like           : ExpLogicalBinary
	| NotLike        : ExpLogicalBinary
	| In             : LogicalIn
	| NotIn          : LogicalIn
	| Exists         : LogicalExists
	| Or             : LogicalBinary
	| And            : LogicalBinary
	| Not            : LogicalUnary
	| Equal          : ExpLogicalBinary
    | NotEqual       : ExpLogicalBinary
	| LessEqual      : ExpLogicalBinary
	| Less           : ExpLogicalBinary
	| GreaterEqual   : ExpLogicalBinary
	| Greater        : ExpLogicalBinary
  }

  abstract ast Unary : Expression 
  { 
    Expr1 : Expression; 
  }   

  abstract ast Binary : Expression 
  { 
    Expr1 : Expression; 
	Expr2 : Expression; 
  }   

  abstract ast ConcatBinary : Binary
  {
  }

  abstract ast SubQueryExpression : Expression
  {
    Query : Query;
  }  

  abstract ast Field
  {
    | SingleField { FieldName : QualifiedIdentifierPart; }
	| TableLinkField { TableLinks : TableLink*; FieldName : QualifiedIdentifierPart;}
  }

  ast TableLink
  {
     LinkName : QualifiedIdentifierPart;
	 LinkDelimiter : LinkDelimiter;
  }

  abstract ast LinkDelimiter
  {
    | FullJoin
	| RightJoin
	| LeftJoin
	| DefaultJoin
  }
  
  abstract ast Expression : BindableAst
  {
      | IntegerLiteral    { Value : int; }
      | FloatLiteral      { Value : double; }
      | StringLiteral     { Value : string; }
      | DateLiteral       { Value : DateTime; }	  
	  | SubQueryExpression
	  | Null
	  | FieldExpression   { Field : Field; }
	  | Case {}
	  | CountAll
	  | FunCall           { FuncName : Field;  Arguments : Expression.Argument*;}
	  | Argument          { Expr : Expression; }
	  | Concat : ConcatBinary
	  | Sum : Binary
	  | Sub : Binary
	  | Modulus : Binary
	  | Multiply : Binary
	  | Divide : Binary
	  | Plus : Unary
	  | Minus : Unary
  }  
}