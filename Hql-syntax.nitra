namespace Hql
{
  syntax module HqlSyntax
  {
    using Nitra.Core;
    using Nitra.CStyleComments;
  
    keyword regex ['A'..'Z','a'..'z', '_'..'_']+ rule S;

    regex KeywordToken =   "from"
                         | "as"
                         | "union"
                         | "all"
                         | "select"
                         | "distinct"
                         | "link"
                         | "join"
                         | "inner"
                         | "left"
                         | "right"
                         | "full"
                         | "where"
                         | "on"
                         | "group"
                         | "order"
                         | "asc"
                         | "desc"
                         | "and"
                         | "or"
                         | "is"
                         | "not"
                         | "null"
                         | "like"
                         | "in"
                         | "exists"
                         | "count"
                         | "having"
                         | "top"
                         | "case"
                         | "when"
                         | "then"
                         | "else"
                         | "end";
  
    [Keyword]   token Keyword   = Name=KeywordToken !IdentifierPartCharacters;
    [Reference] token Reference = !Keyword IdentifierBody;
    [Name]      token Name      = !Keyword IdentifierBody;
    
    // Literals
    regex Digit                               = ['0'..'9'];
    [SpanClass(Number)]
    regex IntegerLiteral                      = Digit+;
    [SpanClass(Number)]
    regex FloatLiteral                         = Digit* "." Digit+;
    [ExplicitSpaces]
    regex DateLiteral                         =   "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit "'"
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "'" 
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "'";
    
    regex SimpleDoubleEscapeSequence          = "\\\"" | "\\\\";

    regex SimpleSingleEscapeSequence          = "\\'" | "\\\\";
    
    regex NotAllowedDoubleStringLiteralChar   = NewLineCharacter | "\"" | "\\";

    regex NotAllowedSingleStringLiteralChar   = NewLineCharacter | "'" | "\\";    

    token DoubleStringLiteralPart
    {
      | SimpleDoubleEscapeSequenceStrPart     = SimpleDoubleEscapeSequence;
      | DoubleStringLiteralCharacterSequence  = (!NotAllowedDoubleStringLiteralChar Any)+;
    }

    token SingleStringLiteralPart
    {
      | SimpleSingleEscapeSequenceStrPart    = SimpleSingleEscapeSequence;
      | SingleStringLiteralCharacterSequence = (!NotAllowedSingleStringLiteralChar Any)+;
    } 

    [SpanClass(String)]
    token StringLiteral
    { 
      | DoubleStringLiteralPart =   "\"" DoubleStringLiteralPart* "\"" 
      | SingleStringLiteralPart = "'" SingleStringLiteralPart* "'"
    }
    
    regex IdentifierStartCharacter   = LetterCharacter | "_";
    regex IdentifierMyPartCharacters = LetterCharacter | DecimalDigitCharacter;

    [ExplicitSpaces]
    syntax QualifiedIdentifierPart
    { 
      | Reference
      | QuotedReference = "[" Reference=(!"]" Any)+ "]"
    }

    syntax StringAlias
    { 
       | QualifiedIdentifierPart
       | StringLiteral = StringLiteral
    }
    
    regex Delimiter = "^" | "->" | "<-" | "." ;


    [ExplicitSpaces]
    syntax QualifiedIdentifier = (QualifiedIdentifierPart; s Delimiter s)+;
    
    [ExplicitSpaces]
    syntax Field
    {
      syntax QIPredicate = Delimiter s QualifiedIdentifierPart s Delimiter;

      | SingleField = QualifiedIdentifierPart;   

    precedence TableLinkAndField:
      | TableLink = (QualifiedIdentifierPart s (&QIPredicate Delimiter s QualifiedIdentifierPart s)? (&QIPredicate Delimiter s)?)+ "." s Field = QualifiedIdentifierPart;	   
    }

    syntax Alias = "as"? StringAlias;
    
    [StartRule]
    syntax Start = Query;

    syntax Query = (SelectStm; "union" "all"?)*;
       
    syntax SelectStm = FromClause? SelectClause WhereClause? GroupClause? OrderClause?;

    syntax SelectClause = "select" "distinct"? ColumnList=(Column; ",")+;

    syntax Column
    {	
       | AllTabAllFields = "*"
       | OneTabAllFields = QualifiedIdentifier ".*"

	  precedence Expr:
	     | Expression
       | ExpressionWithAlias = Expression Alias
    }
  
    syntax FromClause = "from" sm TableSources nl;

	syntax TableSources = (TableSource; ",")*;
	
	syntax TableSource
	{
	  | TableSourceItemJoined
	  | TableSourceItemJoinedWithBrackets = "(" TableSourceItemJoined ")"
	}

	syntax TableSourceItemJoined = TableSourceItem JoinPart*;

	syntax TableSourceItem
	{
      | SubQuery = SubQuery
      | TableNameFull = TableNameFull
    }

	syntax JoinPart
	{
	   | Join = JoinType = JoinType? "join" sm RightTableSource=TableSource sm "on" sm LogicalExpression nl
	   | Link = "link" sm TableNameFull
	}
    
    syntax SubQuery = "(" Query ")" sm Alias;

    syntax TableNameFull = TableName=QualifiedIdentifier sm Alias?;    

    regex OuterJoinType = "left" | "right" | "full";

    syntax JoinType
    {
      | "inner"?
      | OuterJoin = OuterJoinType sm "outer"?
    }

    syntax WhereClause = "where" sm LogicalExpression nl;
     
    syntax HavingClause = "having" sm LogicalExpression nl;

    syntax GroupClause = "group" "by" GroupList=(Expression; ",")+ HavingClause = HavingClause?;

    syntax OrderClause = "order" "by" OrderList=(OrderField; ",")+;

    syntax OrderField
    {
      | OrderAsc  = Expression "asc"?
      | OrderDesc = Expression "desc"
    }

    syntax MyValues
    {
      | QueryExpression    = "(" Query ")"
      | BracketsExpression = "(" (Expression; "," sm)+ ")"
    }       

	regex ComparsionOperator = "=" | "<>" | "<=" | "<" | ">=" | ">";

	syntax LogicalExpression
	{
	  | Braces         = "(" LogicalExpression ")"

	precedence Unary:
      | ValueIsNotNull = Expression "is" "not" "null"
      | ValueIsNull    = Expression "is" "null"
      | Like           = Expression "like" Expression
      | NotLike        = Expression sm "not" sm "like" sm Expression
      | In             = Expression "in" MyValues
      | NotIn          = Expression "not" "in" MyValues

	precedence Or:
      | Or           =  LogicalExpression sm "or" sm LogicalExpression
  
    precedence And:
      | And          = LogicalExpression sm "and" sm LogicalExpression
    
	precedence Not:
	  | Not          = "not" LogicalExpression
      
    precedence Comparsion:
      | Comparsion   = Expression sm ComparsionOperator sm Expression         
	}

    syntax Expression
    {
      | Braces         = "(" Expression ")"
      | Query          = "(" Query ")"
      | Exists         = "exists" "(" Query ")"

      | IntegerLiteral
      | FloatLiteral
      | StringLiteral
      | DateLiteral    = "#" DateLiteral
           
      | Null           = "null"
      | Field          = Field
      | Case           = "case" ("when" Condition=LogicalExpression "then" Then=Expression)+ ("else" Else=Expression)? "end"  
      | CountAll       = "count" "(" "*" ")" 
      | FunCall        = FuncName = Reference "(" (Expression; "," sm)* ")"

    precedence Concat:      
      | Concat       =  Expression sm "&" sm Expression

    precedence Sum:
      | Sum          = Expression sm "+"  sm Expression
      | Sub          = Expression sm "-"  sm Expression
      | Modulus      = Expression sm "%"  sm Expression
      
    precedence Mul:
      | Multiply     = Expression sm "*"  sm Expression
      | Divide       = Expression sm "/"  sm Expression
      
    precedence Unary:
      | Plus          = "+" Expression
      | Minus         = "-" Expression
    }
  }
}