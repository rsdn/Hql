namespace Hql
{
  syntax module HqlSyntax
  {
    using Nitra.Core;
    using Nitra.CStyleComments;
  
    keyword regex ['A'..'Z','a'..'z', '_'..'_']+ rule S;

    regex KeywordToken =   "from"
                         | "as"
                         | "union"
                         | "all"
                         | "select"
                         | "distinct"
                         | "link"
                         | "join"
                         | "inner"
                         | "left"
                         | "right"
                         | "full"
                         | "where"
                         | "on"
                         | "group"
                         | "order"
                         | "asc"
                         | "desc"
                         | "and"
                         | "or"
                         | "is"
                         | "not"
                         | "null"
                         | "like"
                         | "in"
                         | "exists"
                         | "count"
                         | "having"
                         | "top"
                         | "case"
                         | "when"
                         | "then"
                         | "else"
                         | "end";
  
    [Keyword]   token Keyword   = Name=KeywordToken !IdentifierPartCharacters;
    [Reference] token Reference = !Keyword IdentifierBody;
    [Name]      token Name      = !Keyword IdentifierBody;
    
    // Literals
    regex Digit                               = ['0'..'9'];
    [SpanClass(Number)]
    regex IntegerLiteral                      = Digit+;
    [SpanClass(Number)]
    regex FloatLiteral                         = Digit* "." Digit+;
    [ExplicitSpaces]
    regex DateLiteral                         =   "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit "'"
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "'" 
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "'";
    
    regex SimpleDoubleEscapeSequence          = "\\\"" | "\\\\";

    regex SimpleSingleEscapeSequence          = "\\'" | "\\\\";
    
    regex NotAllowedDoubleStringLiteralChar   = NewLineCharacter | "\"" | "\\";

    regex NotAllowedSingleStringLiteralChar   = NewLineCharacter | "'" | "\\";    

    token DoubleStringLiteralPart
    {
      | SimpleDoubleEscapeSequenceStrPart     = SimpleDoubleEscapeSequence;
      | DoubleStringLiteralCharacterSequence  = (!NotAllowedDoubleStringLiteralChar Any)+;
    }

    token SingleStringLiteralPart
    {
      | SimpleSingleEscapeSequenceStrPart    = SimpleSingleEscapeSequence;
      | SingleStringLiteralCharacterSequence = (!NotAllowedSingleStringLiteralChar Any)+;
    } 

    [SpanClass(String)]
    token StringLiteral
    { 
      | DoubleStringLiteralPart =   "\"" DoubleStringLiteralPart* "\"" 
      | SingleStringLiteralPart = "'" SingleStringLiteralPart* "'"
    }
    
    regex IdentifierStartCharacter   = LetterCharacter | "_";
    regex IdentifierMyPartCharacters = LetterCharacter | DecimalDigitCharacter;

    [ExplicitSpaces]
    syntax QualifiedIdentifierPart
    { 
      | Reference
      | QuotedReference = "[" Reference=(!"]" Any)+ "]"
    }

    syntax StringAlias
    { 
       | QualifiedIdentifierPart
       | StringLiteral = StringLiteral
    }
    
    [ExplicitSpaces]
    syntax QualifiedIdentifier
    {
      regex Delimiter = "." | "^" | "->" | "<-";
      syntax QIPredicate = QualifiedIdentifierPart s Delimiter s QualifiedIdentifierPart;

      | QualifiedIdentifierPart
    precedence TableAcces:
      | Ma1 = QualifiedIdentifier s "->" s &QIPredicate QualifiedIdentifier
      | Ma2 = QualifiedIdentifier s "<-" s &QIPredicate QualifiedIdentifier
      | Ma3 = QualifiedIdentifier s "^"  s &QIPredicate QualifiedIdentifier
    precedence MemberAcces:
      | Ma4 = QualifiedIdentifier s "."  s QualifiedIdentifier
    }

    syntax Alias = "as"? StringAlias;
    
    [StartRule]
    syntax Start = Query;

    syntax Query = (SelectStm; "union" "all"?)*;
       
    syntax SelectStm = FromClause? SelectClause WhereClause? GroupClause? OrderClause?;

    syntax SelectClause = "select" "distinct"? ColumnList=(Column; ",")+;

    syntax Column
    {
       | AllTabAllFields = "*"
       | OneTabAllFields = QualifiedIdentifier ".*"
       | Expression
       | ExpressionWithAlias = Expression Alias
    }
  
    syntax FromClause = "from" sm FromMixed nl;

    syntax FromMixed
    {
      | FromComma = FromComma sm
      | TableSource = TableSource sm
    }

    syntax FromComma = TableSource sm "," sm FromMixed;

    syntax TableSource
    {
      | Source
    precedence Join:
      | InnerJoin = LeftTableSource=TableSource sm JoinType? "join" sm RightTableSource=Source sm "on" sm Expression nl
      | Link      = TableSource sm "link" sm TableNameFull
    }

    syntax Source
    {
      | SubQuery = SubQuery
      | TableNameFull = TableNameFull
    }

    syntax SubQuery = "(" Query ")" sm Alias;

    syntax TableNameFull = TableName=QualifiedIdentifier sm Alias?;    

    regex OuterJoinType = "left" | "right" | "full";

    syntax JoinType
    {
      | "inner"?
      | OuterJoin = OuterJoinType sm "outer"?
    }

    syntax WhereClause = "where" sm Expression nl;
     
    syntax HavingClause = "having" sm Expression nl;

    syntax GroupClause = "group" "by" GroupList=(Expression; ",")+ HavingClause = HavingClause?;

    syntax OrderClause = "order" "by" OrderList=(OrderField; ",")+;

    syntax OrderField
    {
      | OrderAsc  = Expression "asc"?
      | OrderDesc = Expression "desc"
    }

    syntax MyValues
    {
      | QueryExpression    = "(" Query ")"
      | BracketsExpression = "(" (Expression; "," sm)+ ")"
    }       

    syntax Expression
    {
      | Braces         = "(" Expression ")"
      | Query          = "(" Query ")"
      | Exists         = "exists" "(" Query ")"

      | IntegerLiteral
      | FloatLiteral
      | StringLiteral
      | DateLiteral    = "#" DateLiteral
           
      | Null           = "null"
      | Field          = QualifiedIdentifier
      | Case           = "case" ("when" Condition=Expression "then" Then=Expression)+ ("else" Else=Expression)? "end"  
      | CountAll       = "count" "(" "*" ")" 
      | FunCall        = FuncName = Reference "(" (Expression; "," sm)* ")" 
      | LogicalNegate  = "not" Expression

    precedence Or:
      | Or           =  Expression sm "or" sm Expression
  
    precedence And:
      | And          = Expression sm "and" sm Expression
      
    precedence Equal:
      | Equal        = Expression sm "="  sm Expression
      | NotEqual     = Expression sm "<>" sm Expression
      
    precedence LessGreater:
      | LessEqual    = Expression sm "<=" sm Expression
      | Less         = Expression sm "<"  sm Expression
      | GreaterEqual = Expression sm ">=" sm Expression
      | Greater      = Expression sm ">"  sm Expression

    precedence Unary:
      | ValueIsNotNull = Expression "is" "not" "null"
      | ValueIsNull    = Expression "is" "null"
      | Like           = Expression "like" Expression
      | NotLike        = Expression sm "not" sm "like" sm Expression
      | In             = Expression "in" MyValues
      | NotIn          = Expression "not" "in" MyValues

    precedence Concat:      
      | Concat       =  Expression sm "&" sm Expression

    precedence Sum:
      | Sum          = Expression sm "+"  sm Expression
      | Sub          = Expression sm "-"  sm Expression
      | Modulus      = Expression sm "%"  sm Expression
      
    precedence Mul:
      | Multiply     = Expression sm "*"  sm Expression
      | Divide       = Expression sm "/"  sm Expression
      
    precedence Unary:
      | Plus          = "+" Expression
      | Minus         = "-" Expression
    }
  }
}