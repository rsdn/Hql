namespace Hql
{
  syntax module HqlSyntax
  {
    using Nitra.Core;
    using Nitra.CStyleComments;
  
    keyword regex ['A'..'Z','a'..'z', '_'..'_']+ rule S;

    regex KeywordToken =   "from"
                         | "as"
                         | "union"
                         | "all"
                         | "select"
                         | "distinct"
                         | "link"
                         | "join"
                         | "inner"
                         | "left"
                         | "right"
                         | "full"
                         | "where"
                         | "on"
                         | "group"
                         | "order"
                         | "asc"
                         | "desc"
                         | "and"
                         | "or"
                         | "is"
                         | "not"
                         | "null"
                         | "like"
                         | "in"
                         | "exists"
                         | "count"
                         | "having"
                         | "top"
                         | "case"
                         | "when"
                         | "then"
                         | "else"
                         | "end";
  
    [Keyword]   token Keyword   = Name=KeywordToken !IdentifierPartCharacters;
    [Reference] token Reference = !Keyword IdentifierBody;
    [Name]      token Name      = !Keyword IdentifierBody;
    
    // Literals
    regex Digit                               = ['0'..'9'];
    [SpanClass(Number)]
    regex IntegerLiteral                      = Digit+;
    [SpanClass(Number)]
    regex FloatLiteral                         = Digit* "." Digit+;
    [ExplicitSpaces]
    regex DateLiteral                         =   "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit "'"
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit ":" Digit Digit "'" 
                                                | "\"" Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "\""
                                                | "'"  Digit Digit "." Digit Digit "." Digit Digit Digit Digit " " Digit Digit ":" Digit Digit "'";
    
    regex SimpleDoubleEscapeSequence          = "\\\"" | "\\\\";

    regex SimpleSingleEscapeSequence          = "\\'" | "\\\\";
    
    regex NotAllowedDoubleStringLiteralChar   = NewLineCharacter | "\"" | "\\";

    regex NotAllowedSingleStringLiteralChar   = NewLineCharacter | "'" | "\\";    

    token DoubleStringLiteralPart
    {
      | SimpleDoubleEscapeSequenceStrPart     = SimpleDoubleEscapeSequence;
      | DoubleStringLiteralCharacterSequence  = (!NotAllowedDoubleStringLiteralChar Any)+;
    }

    token SingleStringLiteralPart
    {
      | SimpleSingleEscapeSequenceStrPart    = SimpleSingleEscapeSequence;
      | SingleStringLiteralCharacterSequence = (!NotAllowedSingleStringLiteralChar Any)+;
    } 

    [SpanClass(String)]
    token StringLiteral
    { 
      | DoubleStringLiteralPart =   "\"" DoubleStringLiteralPart* "\"" 
      | SingleStringLiteralPart = "'" SingleStringLiteralPart* "'"
    }
    
    regex IdentifierStartCharacter   = LetterCharacter | "_";
    regex IdentifierMyPartCharacters = LetterCharacter | DecimalDigitCharacter;

    [ExplicitSpaces]
    syntax QualifiedIdentifierPart
    { 
      | Reference
      | QuotedReference = "[" Reference=(!"]" Any)+ "]"
    }

    syntax StringAlias
    { 
       | QualifiedIdentifierPart
       | StringLiteral = StringLiteral
    }
        
	syntax Delimiter
	{
	   | FullJoin = "^"
	   | RightJoin = "->"
	   | LeftJoin = "<-"
	   | DefaultJoin = "."
	}


    [ExplicitSpaces]
    syntax QualifiedIdentifier = (QualifiedIdentifierPart; s Delimiter s)+;
    
    [ExplicitSpaces]
    syntax Field
    {
      syntax QIPredicate = Delimiter s QualifiedIdentifierPart s Delimiter;

      | SingleField = QualifiedIdentifierPart;   

    precedence TableLinkAndField:
      | TableLink = (QualifiedIdentifierPart s (&QIPredicate Delimiter s QualifiedIdentifierPart s)? (&QIPredicate Delimiter s)?)+ "." s Field = QualifiedIdentifierPart;	   
    }

    syntax Alias = ("as" sm)? StringAlias;
    
    [StartRule]
    syntax Start = Query;

	syntax Query = (SelectStm; UnionType nl)*;

	syntax UnionType
	{
	  | Union = "union"
	  | UnionAll = "union" sm "all"
	}
       
    syntax SelectStm = FromClause? SelectClause WhereClause? GroupClause? OrderClause?;

    syntax SelectClause = "select" sm ("distinct" sm)? ColumnList=(Column; "," sm)+ nl;

    syntax Column
    {	
       | AllTabAllFields = "*"
       | OneTabAllFields = QualifiedIdentifier ".*"

	  precedence Expr:
	   | Expression
       | ExpressionWithAlias = Expression Alias
    }
  
    syntax FromClause = "from" sm TableSources;

	syntax TableSources = (TableSource; ",")*;
	
	syntax TableSource
	{
	  | TableSourceItemJoined
	  | TableSourceItemJoinedWithBrackets = "(" TableSourceItemJoined ")"
	}

	syntax TableSourceItemJoined = TableSourceItem JoinPart*;

	syntax TableSourceItem
	{
      | SubQuery = SubQuery
      | TableNameFull = TableNameFull nl
    }

	syntax JoinPart
	{
	   | Join = JoinType = JoinType? "join" sm RightTableSource=TableSource sm "on" sm LogicalExpression nl
	   | Link = "link" sm TableNameFull nl
	}
    
    syntax SubQuery = "(" Query ")" sm Alias sm;

    syntax TableNameFull = TableName=QualifiedIdentifier sm Alias=(Alias sm)?;

	syntax OuterJoinType
	{
	  | Left = "left"
	  | Right = "right"
	  | Full = "full"
	}

    syntax JoinType
    {
      | Inner = "inner"?
      | OuterJoin = OuterJoinType sm ("outer" sm)?
    }

    syntax WhereClause = "where" sm LogicalExpression nl;
     
    syntax HavingClause = "having" sm LogicalExpression nl;

    syntax GroupClause = "group" "by" GroupList=(Expression; "," sm)+ nl HavingClause = HavingClause?;

    syntax OrderClause = "order" "by" OrderList=(OrderField; "," sm)+ nl;

    syntax OrderField
    {
      | OrderAsc  = Expression sm "asc"?
      | OrderDesc = Expression sm "desc"
    }

    syntax MyValues
    {
      | QueryExpression    = "(" Query ")"
      | BracketsExpression = "(" (Expression; "," sm)+ ")"
    }       

	regex ComparsionOperator = "=" | "<>" | "<=" | "<" | ">=" | ">";

	syntax LogicalExpression
	{
	  | Braces         = "(" LogicalExpression ")"

	precedence Unary:
      | ValueIsNotNull = Expression sm "is" sm "not" sm "null"
      | ValueIsNull    = Expression sm "is" sm "null"
      | Like           = Expression sm "like" sm Expression
      | NotLike        = Expression sm "not" sm "like" sm Expression
      | In             = Expression sm "in" sm MyValues
      | NotIn          = Expression sm "not" sm "in" sm MyValues
	  | Exists         = "exists" sm "(" Query ")"

	precedence Or:
      | Or           =  LogicalExpression sm "or" nl LogicalExpression sm
  
    precedence And:
      | And          = LogicalExpression sm "and" nl LogicalExpression sm
    
	precedence Not:
	  | Not          = "not" sm LogicalExpression
      
    precedence Comparsion:
      | Comparsion   = Expression sm ComparsionOperator sm Expression         
	}

    syntax Expression
    {
      | Braces         = "(" Expression ")"
      | Query          = "(" Query ")"      

      | IntegerLiteral
      | FloatLiteral
      | StringLiteral
      | DateLiteral    = "#" DateLiteral
           
      | Null           = "null"
      | Field          = Field
      | Case           = "case" nl ("when" sm Condition=LogicalExpression sm "then" sm Then=Expression nl)+ ("else" sm Else=Expression nl)? "end" nl 
      | CountAll       = "count" "(" "*" ")" 
      | FunCall        = FuncName = Reference "(" (Expression; "," sm)* ")"

    precedence Concat:      
      | Concat       =  Expression sm "&" sm Expression

    precedence Sum:
      | Sum          = Expression sm "+"  sm Expression
      | Sub          = Expression sm "-"  sm Expression
      | Modulus      = Expression sm "%"  sm Expression
      
    precedence Mul:
      | Multiply     = Expression sm "*"  sm Expression
      | Divide       = Expression sm "/"  sm Expression
      
    precedence Unary:
      | Plus          = "+" Expression
      | Minus         = "-" Expression
    }
  }
}